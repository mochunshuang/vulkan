#pragma once

#include "random_double.hpp"
#include "vec3.hpp"

/*
NOTE:Perlinå™ªå£°ç”Ÿæˆå™¨:å°±åƒå¤§è‡ªç„¶ä¸­çš„äº‘å½©ã€å¤§ç†çŸ³çº¹ç†ã€åœ°å½¢ç­‰éšæœºä½†åˆè¿è´¯çš„å›¾æ¡ˆ
ä¸ºä»€ä¹ˆè¿™æ ·è®¾è®¡ï¼Ÿ
1. å¯é‡å¤æ€§
    ç›¸åŒçš„è¾“å…¥åæ ‡ â†’ ç›¸åŒçš„å™ªå£°å€¼
    é€‚åˆè®¡ç®—æœºå›¾å½¢å­¦ï¼ˆéœ€è¦ç¡®å®šæ€§ç»“æœï¼‰

2. ç©ºé—´è¿ç»­æ€§
    ç›¸é‚»ç‚¹ä½¿ç”¨ç›¸ä¼¼çš„ç´¢å¼•ç»„åˆ
    äº§ç”Ÿå¹³æ»‘è¿‡æ¸¡çš„å™ªå£°å›¾æ¡ˆ

3. é«˜æ•ˆæ€§
    é€šè¿‡é¢„è®¡ç®—çš„æ’åˆ—è¡¨é¿å…å¤æ‚è®¡ç®—
    ç®€å•çš„ä½è¿ç®—å®ç°å¿«é€ŸæŸ¥æ‰¾

randfloat[256] = 256ä¸ªéšæœºç”µè¯å·ç 
perm_x, perm_y, perm_z = ä¸‰ä¸ªç»´åº¦çš„åŠ å¯†æ˜ å°„è¡¨

*/
// NOLINTBEGIN
class perlin
{
  public:
    perlin()
    {
        for (double &i : randfloat)
        {
            i = random_double();
        }

        perlin_generate_perm(perm_x);
        perlin_generate_perm(perm_y);
        perlin_generate_perm(perm_z);
    }

    /*
    æœ€å¤§å¯èƒ½å€¼ï¼š255 ^ 255 ^ 255
    255äºŒè¿›åˆ¶: 11111111
    11111111 ^ 11111111 = 00000000
    00000000 ^ 11111111 = 11111111 = 255
    æœ€å°å¯èƒ½å€¼ï¼š0 ^ 0 ^ 0 = 0
    */
    [[nodiscard]] double noise_nosmooth(const point3 &p) const
    {
        // æ­¥éª¤1ï¼šå°†3Dåæ ‡ç¦»æ•£åŒ–ä¸ºæ•´æ•°ç½‘æ ¼ç´¢å¼•
        constexpr auto k_max_value = 255;
        auto i = static_cast<int>(4 * p.x()) & k_max_value;
        auto j = static_cast<int>(4 * p.y()) & k_max_value;
        auto k = static_cast<int>(4 * p.z()) & k_max_value;

        // æ­¥éª¤2ï¼šé€šè¿‡æ’åˆ—è¡¨æ··åˆä¸‰ä¸ªç»´åº¦çš„ç´¢å¼•
        // æ­¥éª¤3ï¼šä»éšæœºæµ®ç‚¹æ•°æ•°ç»„ä¸­è·å–æœ€ç»ˆå™ªå£°å€¼
        return randfloat[perm_x[i] ^ perm_y[j] ^ perm_z[k]];
    }

    [[nodiscard]] double noise(const point3 &p) const
    {
        auto u = p.x() - std::floor(p.x());
        auto v = p.y() - std::floor(p.y());
        auto w = p.z() - std::floor(p.z());

        // u = u;  // ç›´æ¥ä½¿ç”¨ï¼Œçº¿æ€§å˜åŒ–.æ•ˆæœï¼šä»0åˆ°1ç›´çº¿å˜åŒ–ï¼Œåœ¨ç½‘æ ¼è¾¹ç•Œå¤„å¯¼æ•°ä¸è¿ç»­

        /*
        f(u) = 3uÂ² - 2uÂ³

        åœ¨ u=0: f(0) = 0, f'(0) = 0     â† èµ·ç‚¹å¯¼æ•°ä¸º0
        åœ¨ u=1: f(1) = 1, f'(1) = 0     â† ç»ˆç‚¹å¯¼æ•°ä¸º0
        åœ¨ u=0.5: f(0.5) = 0.5, f'(0.5) = 1.5 â† ä¸­é—´å˜åŒ–æœ€å¿«

        çº¿æ€§æ’å€¼ï¼šçªç„¶åŠ é€Ÿçš„æ±½è½¦
        èµ·ç‚¹(0) â†’ ç«‹å³å…¨é€Ÿ â†’ ç»ˆç‚¹(1)çªç„¶åˆ¹è½¦
            ğŸš—ğŸ’¨---------------ğŸ’¥ğŸ›‘

        å¹³æ»‘æ­¥å‡½æ•°ï¼šå¹³ç¨³é©¾é©¶çš„æ±½è½¦
        èµ·ç‚¹(0) â†’ ç¼“æ…¢åŠ é€Ÿ â†’ åŒ€é€Ÿ â†’ ç¼“æ…¢å‡é€Ÿ â†’ ç»ˆç‚¹(1)
            ğŸš—..â¤´ï¸.............â¤µï¸..

        è¿™ä¸ª u*u*(3-2*u) æ˜¯Perlinå™ªå£°çš„å…³é”®æ”¹è¿›ï¼Œå®ƒç¡®ä¿äº†ï¼š

            ç½‘æ ¼è¾¹ç•Œæ— ç¼è¡”æ¥
            æ¶ˆé™¤çº¿æ€§æ’å€¼çš„æœºæ¢°æ„Ÿ
            äº§ç”Ÿæ›´è‡ªç„¶çš„æœ‰æœºå›¾æ¡ˆ

        æ­£æ˜¯è¿™ä¸ªå°å°çš„æ•°å­¦æŠ€å·§ï¼Œè®©Perlinå™ªå£°ä»"å—çŠ¶éšæœº"å˜æˆäº†"äº‘æœµèˆ¬è‡ªç„¶"ï¼
        */
        // NOTE: å¹³æ»‘æ­¥å‡½æ•°ï¼šæ•ˆæœï¼šä»0åˆ°1å¹³æ»‘Så½¢å˜åŒ–ï¼Œè¾¹ç•Œå¤„å¯¼æ•°ä¸ºé›¶
        u = u * u * (3 - 2 * u);
        v = v * v * (3 - 2 * v);
        w = w * w * (3 - 2 * w);

        auto i = static_cast<int>(std::floor(p.x()));
        auto j = static_cast<int>(std::floor(p.y()));
        auto k = static_cast<int>(std::floor(p.z()));
        double c[2][2][2]; // 2Ã—2Ã—2çš„ç«‹æ–¹ä½“è§’ç‚¹

        for (int di = 0; di < 2; di++)
            for (int dj = 0; dj < 2; dj++)
                for (int dk = 0; dk < 2; dk++)
                    c[di][dj][dk] =
                        randfloat[perm_x[(i + di) & 255] ^ perm_y[(j + dj) & 255] ^
                                  perm_z[(k + dk) & 255]];

        return trilinear_interp(c, u, v, w);
    }

  private:
    static const int point_count = 256;
    double randfloat[point_count];
    int perm_x[point_count];
    int perm_y[point_count];
    int perm_z[point_count];

    static void perlin_generate_perm(int *p)
    {
        for (int i = 0; i < point_count; i++)
            p[i] = i;

        permute(p, point_count);
    }

    // ç„¶åéšæœºæ‰“ä¹±é¡ºåºï¼ˆæ´—ç‰Œç®—æ³•ï¼‰
    static void permute(int *p, int n)
    {
        for (int i = n - 1; i > 0; i--)
        {
            int target = random_int(0, i);
            int tmp = p[i];
            p[i] = p[target];
            p[target] = tmp;
        }
    }

    // NOTE: å…‰æ»‘çš„é­”æ³•ï¼šä¸‰çº¿æ€§æ’å€¼
    static double trilinear_interp(double c[2][2][2], double u, double v, double w)
    {
        auto accum = 0.0;
        for (int i = 0; i < 2; i++)
            for (int j = 0; j < 2; j++)
                for (int k = 0; k < 2; k++)
                    accum += (i * u + (1 - i) * (1 - u)) * (j * v + (1 - j) * (1 - v)) *
                             (k * w + (1 - k) * (1 - w)) * c[i][j][k];

        return accum;
    }
};

class perlin_with_random_vec
{
  public:
    perlin_with_random_vec()
    {
        for (int i = 0; i < point_count; i++)
        {
            // éå¸¸èªæ˜çš„æŠ€å·§æ˜¯åœ¨æ ¼ç‚¹ä¸Šæ”¾ç½®éšæœºå•ä½å‘é‡ï¼ˆè€Œä¸ä»…ä»…æ˜¯æµ®ç‚¹æ•°ï¼‰ï¼Œå¹¶ä½¿ç”¨ç‚¹ç§¯å°†æœ€å°å€¼å’Œæœ€å¤§å€¼ç§»å‡ºæ ¼å­ã€‚
            // æ‰€ä»¥ï¼Œé¦–å…ˆæˆ‘ä»¬éœ€è¦å°†éšæœºæµ®ç‚¹æ•°æ›´æ”¹ä¸ºéšæœºå‘é‡ã€‚è¿™äº›å‘é‡æ˜¯ä»»ä½•åˆç†çš„ä¸è§„åˆ™æ–¹å‘é›†ï¼Œæˆ‘ä¸ä¼šè´¹å¿ƒè®©å®ƒä»¬å®Œå…¨ç»Ÿä¸€
            // NOTE: ç”¨éšæœºå•ä½å‘é‡ä»£æ›¿éšæœºæµ®ç‚¹æ•°ï¼
            randvec[i] = unit_vector(vec3::random(-1, 1));
        }

        perlin_generate_perm(perm_x);
        perlin_generate_perm(perm_y);
        perlin_generate_perm(perm_z);
    }

    [[nodiscard]] double noise(const point3 &p) const
    {
        // æ­¥éª¤1ï¼šè®¡ç®—åœ¨ç½‘æ ¼å•å…ƒå†…çš„å°æ•°åæ ‡
        auto u = p.x() - std::floor(p.x()); // [0,1)
        auto v = p.y() - std::floor(p.y());
        auto w = p.z() - std::floor(p.z());

        // æ­¥éª¤2ï¼šè®¡ç®—å½“å‰ç½‘æ ¼å•å…ƒçš„æ•´æ•°åæ ‡
        auto i = static_cast<int>(std::floor(p.x()));
        auto j = static_cast<int>(std::floor(p.y()));
        auto k = static_cast<int>(std::floor(p.z()));

        /*
        æƒ³è±¡3Dç©ºé—´ä¸­æœ‰å¾ˆå¤šé£å‘æ ‡ï¼ˆæ¢¯åº¦å‘é‡ï¼‰ï¼š
        è®¡ç®—è¿‡ç¨‹ï¼š
            å¯¹äºæ¯ä¸ªæ ¼ç‚¹ï¼Œè®¡ç®—ä»æ ¼ç‚¹æŒ‡å‘ä½ çš„å‘é‡
            è®¡ç®—é£å‘ä¸æŒ‡å‘å‘é‡çš„ç‚¹ç§¯ï¼ˆé£å‘å¯¹ä½ çš„å½±å“ç¨‹åº¦ï¼‰
            æ ¹æ®è·ç¦»åŠ æƒå¹³å‡æ‰€æœ‰æ ¼ç‚¹çš„å½±å“

        åº”ç”¨ï¼šäº‘å½©ã€å¤§ç†çŸ³ã€ç«ç„°ã€åœ°å½¢ç­‰è‡ªç„¶çº¹ç†
        */
        // æ­¥éª¤3ï¼šè·å–å‘¨å›´8ä¸ªæ ¼ç‚¹çš„æ¢¯åº¦å‘é‡
        vec3 c[2][2][2];
        for (int di = 0; di < 2; di++)
            for (int dj = 0; dj < 2; dj++)
                for (int dk = 0; dk < 2; dk++)
                    c[di][dj][dk] =
                        randvec[perm_x[(i + di) & 255] ^ perm_y[(j + dj) & 255] ^
                                perm_z[(k + dk) & 255]];

        // æ­¥éª¤4ï¼šä¸‰çº¿æ€§æ’å€¼
        return perlin_interp(c, u, v, w);
    }

    /*
    é€šå¸¸ä½¿ç”¨å…·æœ‰å¤šä¸ªæ±‚å’Œé¢‘ç‡çš„å¤åˆå™ªå£°ã€‚è¿™é€šå¸¸ç§°ä¸ºæ¹æµï¼Œæ˜¯å¯¹å™ªå£°çš„é‡å¤è°ƒç”¨çš„æ€»å’Œï¼š

å•ä¸€å™ªå£° (depth=1)ï¼š
    å¹³æ»‘çš„äº‘çŠ¶å›¾æ¡ˆï¼Œç¼ºä¹ç»†èŠ‚
æ¹æµå™ªå£° (depth=7)ï¼š
    ä¸°å¯Œçš„å¤šå°ºåº¦ç»†èŠ‚ï¼ŒåƒçœŸå®çš„å¤§ç†çŸ³ã€ç«ç„°ã€åœ°å½¢

æ ¸å¿ƒæ€æƒ³ï¼šåˆ†å½¢å åŠ 
é€šè¿‡å åŠ å¤šä¸ªä¸åŒé¢‘ç‡çš„å™ªå£°æ¥äº§ç”Ÿæ›´å¤æ‚çš„è‡ªç„¶å›¾æ¡ˆï¼

ğŸª ç”ŸåŠ¨æ¯”å–»ï¼šå¤šå±‚æ»¤é•œå åŠ 
æƒ³è±¡ç”¨ä¸åŒæ”¾å¤§é•œè§‚å¯Ÿçº¹ç†ï¼š
    ç¬¬1å±‚ï¼šæ­£å¸¸è§†å›¾ â†’ çœ‹åˆ°å¤§å°ºåº¦ç‰¹å¾
    ç¬¬2å±‚ï¼š2å€æ”¾å¤§ â†’ çœ‹åˆ°ä¸­ç­‰ç»†èŠ‚
    ç¬¬3å±‚ï¼š4å€æ”¾å¤§ â†’ çœ‹åˆ°ç»†å°ç‰¹å¾
    ç¬¬4å±‚ï¼š8å€æ”¾å¤§ â†’ çœ‹åˆ°å¾®ç»“æ„
    ...
    æ¯å±‚è´¡çŒ®é€æ¸å‡åŠï¼

ğŸ’¡ ä¸ºä»€ä¹ˆå«"æ¹æµ"ï¼Ÿ
    å› ä¸ºè¿™ç§å¤šå°ºåº¦å åŠ äº§ç”Ÿçš„å›¾æ¡ˆå¾ˆåƒï¼š
    æ°´æµæ¹æµçš„å¤šå°ºåº¦æ¶¡æ—‹
    ç«ç„°çš„å±‚å±‚ç«èˆŒ
    äº‘å½©çš„å¤§å°å›¢å—
    å¤§ç†çŸ³çš„å¤æ‚è„‰ç»œ

æ€»ç»“ï¼šæ¹æµå™ªå£°é€šè¿‡åˆ†å½¢å åŠ ï¼Œå°†ç®€å•çš„Perlinå™ªå£°å‡çº§ä¸ºèƒ½å¤Ÿæ¨¡æ‹Ÿå„ç§å¤æ‚è‡ªç„¶ç°è±¡çš„å¼ºå¤§å·¥å…·ï¼è¿™æ˜¯è®¡ç®—æœºå›¾å½¢å­¦ä¸­ç”Ÿæˆé€¼çœŸçº¹ç†çš„æ ¸å¿ƒæŠ€æœ¯ä¹‹ä¸€
    */
    // NOTE: è°ƒç”¨å™ªå£°ã€‚turbulenceï¼šéªšä¹±ï¼ŒåŠ¨è¡ï¼›ï¼ˆç©ºæ°”æˆ–æ°´çš„ï¼‰æ¹æµï¼Œç´Šæµ
    double turb(const point3 &p, int depth) const
    {
        /*
        1. é¢‘ç‡å€å¢ temp_p *= 2
        æ¯æ¬¡è¿­ä»£é‡‡æ ·æ›´é«˜é¢‘çš„å™ªå£°
        æ·»åŠ æ›´å°å°ºåº¦çš„ç»†èŠ‚

        2. æŒ¯å¹…è¡°å‡ weight *= 0.5
        é«˜é¢‘æˆåˆ†è´¡çŒ®è¾ƒå°ï¼ˆç¬¦åˆè‡ªç„¶ç°è±¡ï¼‰
        ç¡®ä¿çº§æ•°æ”¶æ•›

        3. ç»å¯¹å€¼ std::fabs(accum)
        å°†èŒƒå›´ä»å¤§çº¦[-2,2]æ˜ å°„åˆ°[0,2]
        äº§ç”Ÿæ›´é²œæ˜çš„å¯¹æ¯”åº¦

        è®¡ç®—ç†è®ºæå€¼ï¼š
        æœ€å¤§å¯èƒ½å€¼ï¼ˆæ‰€æœ‰å™ªå£°é¡¹éƒ½å–+1ï¼‰ï¼š
            1.0 + 0.5 + 0.25 + 0.125 + 0.0625 + 0.03125 + 0.015625
            = 1.984375 â‰ˆ 2.0
        æœ€å°å¯èƒ½å€¼ï¼ˆæ‰€æœ‰å™ªå£°é¡¹éƒ½å–-1ï¼‰ï¼š
            -1.0 - 0.5 - 0.25 - 0.125 - 0.0625 - 0.03125 - 0.015625
            = -1.984375 â‰ˆ -2.0

        // é€šè¿‡å®éªŒè§‚æµ‹ï¼Œæ¹æµå™ªå£°çš„å…¸å‹èŒƒå›´ï¼š
        turb(p) âˆˆ [-1.5, +1.5]  // å¤§éƒ¨åˆ†æ—¶é—´åœ¨è¿™ä¸ªèŒƒå›´


        NOTE: ğŸ”§ ä¸ºä»€ä¹ˆéœ€è¦ç»å¯¹å€¼ï¼Ÿ
        é—®é¢˜ï¼šåŸå§‹æ¹æµæœ‰æ­£æœ‰è´Ÿ
            å€¼åˆ†å¸ƒï¼š-1.2, -0.8, 0.3, 1.1, -0.5, 0.9, ...
            ä½œä¸ºé¢œè‰²å€¼ï¼šè´Ÿæ•°æ²¡æœ‰æ„ä¹‰ï¼
        è§£å†³æ–¹æ¡ˆï¼šå–ç»å¯¹å€¼
            return std::fabs(accum);  // æ˜ å°„åˆ° [0, 2] èŒƒå›´
        */

        auto accum = 0.0;
        auto temp_p = p;
        auto weight = 1.0;

        for (int i = 0; i < depth; i++)
        {
            accum += weight * noise(temp_p);
            // 2. æŒ¯å¹…è¡°å‡ weight *= 0.5
            weight *= 0.5;
            // 1. é¢‘ç‡å€å¢ temp_p *= 2
            temp_p *= 2;
        }
        return std::fabs(accum); // NOTE: é¢œè‰²è´Ÿæ•°ï¼Œæ²¡æœ‰æ„ä¹‰
    }

  private:
    static const int point_count = 256;
    vec3 randvec[point_count]; // NOTE: å‘é‡è€Œä¸æ˜¯ç‚¹
    int perm_x[point_count];
    int perm_y[point_count];
    int perm_z[point_count];

    static void perlin_generate_perm(int *p)
    {
        for (int i = 0; i < point_count; i++)
            p[i] = i;

        permute(p, point_count);
    }

    // ç„¶åéšæœºæ‰“ä¹±é¡ºåºï¼ˆæ´—ç‰Œç®—æ³•ï¼‰
    static void permute(int *p, int n)
    {
        for (int i = n - 1; i > 0; i--)
        {
            int target = random_int(0, i);
            int tmp = p[i];
            p[i] = p[target];
            p[target] = tmp;
        }
    }

    // NOTE: å…‰æ»‘çš„é­”æ³•ï¼šä¸‰çº¿æ€§æ’å€¼
    static double perlin_interp(const vec3 c[2][2][2], double u, double v, double w)
    {
        // åº”ç”¨å¹³æ»‘æ­¥å‡½æ•°
        auto uu = u * u * (3 - 2 * u); // Så½¢æ›²çº¿
        auto vv = v * v * (3 - 2 * v);
        auto ww = w * w * (3 - 2 * w);

        auto accum = 0.0;

        for (int i = 0; i < 2; i++)
            for (int j = 0; j < 2; j++)
                for (int k = 0; k < 2; k++)
                {
                    // å…³é”®ï¼šè®¡ç®—ä»æ ¼ç‚¹åˆ°é‡‡æ ·ç‚¹çš„å‘é‡
                    vec3 weight_v(u - i, v - j, w - k);

                    // ä¸‰çº¿æ€§æƒé‡ Ã— ç‚¹ç§¯ç»“æœ
                    accum += (i * uu + (1 - i) * (1 - uu)) *
                             (j * vv + (1 - j) * (1 - vv)) *
                             (k * ww + (1 - k) * (1 - ww)) *
                             dot(c[i][j][k], weight_v); // ç‚¹ç§¯ï¼
                }

        return accum;
    }
};
// NOLINTEND